Задачи
1. Настроить .gitignore
Критерии приемки:
В репозитории нет файлов, которые генерируются автоматически в процессе сборки.

2. Настроить github CI pipeline, который:
собирает проект,
выполняет все тесты,
вычисляет коэффициент покрытия кода тестами,
публикует в комментариях отчет о покрытии.
Критерий приемки:
Pipeline срабатывает только на PR.
Pipeline оптимально расходует минуты, например, не производит компиляцию проекта повторно при выполнении тестирования.
Важно! Коэффициент покрытия кода тестами любого PR должен быть больше 90%.

3. Определить интерфейс для команд.
Критерии приемки:
Определен базовый интерфейс ICommand для всех команд, удовлетворящий SOLID.

✔    4. Вектор в n-мерном пространстве.
    Для представления скорости, положения объекта в пространстве реализовать класс Vector, который является моделью вектора n-мерного пространства с целочисленными координатами. Для векторов должна быть реализована операция сложения.

    Критерии приемки:

    Класс реализует вектор пространства любой размерности.
    Реализован тест, который проверяет, что при сложении веткоров (1, -1, 2) и (-1, 1, -2) получается вектор (0,0,0).
    Реализован тест, который проверяет, что при сложении векторов (1, 2, 3) И (1, 2) выбрасывается исключение ArgumentException.
    Реализован тест, который проверяет, что при сложении векторов (1, 2) И (1, 2, 3) выбрасывается исключение ArgumentException.
    Реализован тест, который проверят, что два покоординатно совпадающих вектора, но разных объекта, равны между собой при сравнении через метод Equals.
    Реализован тест, который проверят, что два покоординатно совпадающих вектора, но разных объекта, равны между собой при сравнении через метод ==.
    Реализован тест, который проверят, что два покоординатно несовпадающих вектора, неравны между собой при сравнении через метод Equals.
    Реализован тест, который проверят, что два покоординатно несовпадающих вектора, неравны между собой при сравнении через метод !=.
    Реализован тест, который проверяет наличие хэш-кода у вектора.

✔     5. Определить команду Move для равномерного поступательного движения без деформации.
    Команда MoveCommand выполняет равномерное поступательное движение объекта без деформации за один дискретный момент времени.

    Критерии приемки:

    Реализован тест, который проверяет, что если движущийся объект находится в точке пространства с координатами (12,5) и имеет мгновенную скорость (-4, 1), то в следующий дискретный момент времени он окажется в точке пространства с координатами (8, 6).
    Реализован тест, который проверяет, что если невозможно определить местонахождение движущегося объекта в пространстве, то команда Move выбрасывает исключение.
    Реализован тест, который проверяет, что если у движущегося объекта невозможно определить скорость, то команда Move выбрасывает исключение.
    Реализован тест, который проверяет, что если у движущегося объекта невозможно изменить местонахождение, то команда Move выбрасывает исключение.

6. Регистрация зависимости Commands.Move в IoC.
Зарегистрировать зависимость "Commands.Move" в IoC, с помощью которой можно разрешить команду MoveCommand по игровому объекту. Для регистрации зависимости определить отдельную команду с префиксом RegisterIoCDependency:

public class RegisterIoCDependencyMoveCommand : ICommand
{
    public void Execute()
  {
      // код, регистрирующий зависимость
    }
}
Примечание: Для того, чтобы создать MoveCommand, необходимо создать адаптер IDictionary<string, object> для интерфейса IMovingObject. Задача конструирования Адаптеров по интерфейсу будет рассмотрена в другой лабораторной работе, поэтому в данной задаче используйте разрешение зависимости Ioc.Resolve("Adapters.IMovingObject", obj), где obj - игровой объект. В тестах используйте Mock-объекты, для разрешения этой зависимости.

Критерии приемки:

Реализован тест, который проверяет, что при выполнении Execute класса RegisterIoCDependencyMoveCommand зависимость разрешается.

✔     7. Угол на плоскости.
    Для представления угла наклона к оси OX игрового объекта реализовать класс Angle. Внутри Angle представлен как рациональное число, причем знаменатель у всех углов будет одинаковый (его можно сделать статическим полем). Для угла должна быть реализована операция сложения и должна быть возможность вычисления синуса и косинуса от Angle без предварительного явного приведения к типу Double: Math.Cos(angle).

    Критерии приемки:

    Реализован тест, который проверяет, что при сложении углов (5, 8) и (7, 8) получается вектор (4,8).
    Реализован тест, который проверят, что два угла (15, 8) и (23, 8), равны между собой при сравнении через метод Equals.
    Реализован тест, который проверят, что два угла (15, 8) и (23, 8), равны между собой при сравнении через метод ==.
    Реализован тест, который проверят, что углы (1,8) и (2, 8) неравны между собой при сравнении через метод Equals.
    Реализован тест, который проверят, что углы (1,8) и (2, 8) неравны между собой при сравнении через метод !=.
    Реализован тест, который проверяет наличие хэш-кода у угла.

✔    8. Определить команду Rotate для равномерного вращения вокруг собственной оси.
    Команда выполняет равномерное поступальное движение объекта без деформации за один дискретный момент времени.

    Критерии приемки:

    Реализован тест, который проверяет, что если вращающийся объект имеет угол наклона 45 градусов к оси OX и имеет мгновенную угловую скорость скорость 45 градусов, то в следующий дискретный момент времени угол наклона к оси OX будет 90 градусов.
    Реализован тест, который проверяет, что если невозможно определить угол наклона объекта к оси OX, то команда Rotate выбрасывает исключение.
    Реализован тест, который проверяет, что если у вращающегося объекта невозможно определить мгновенную угловую скорость, то команда Rotate выбрасывает исключение.
    Реализован тест, который проверяет, что еcли у движущегося объекта невозможно изменить угол наклона к оси OX, то команда Rotate выбрасывает исключение.

9. Регистрация зависимости Commands.Rotate в IoC.
Зарегистрировать зависимость "Commands.Rotate" в IoC, с помощью которой можно разрешить команду MoveCommand по игровому объекту. Для регистрации зависимости определить отдельную команду с префиксом RegisterIoCDependency:

public class RegisterIoCDependencyRotateCommand : ICommand
{
    public void Execute()
  {
      // код, регистрирующий зависимость
    }
}
Примечание: Для того, чтобы создать RotateCommand, необходимо создать адаптер IDictionary<string, object> для интерфейса IRotatingObject. Задача конструирования Адаптеров по интерфейсу будет рассмотрена в другой лабораторной работе, поэтому в данной задаче используйте разрешение зависимости Ioc.Resolve("Adapters.IRotatingObject", obj), где obj - игровой объект. В тестах используйте Mock-объекты, для разрешения этой зависимости.

Критерии приемки:

Реализован тест, который проверяет, что при выполнении Execute класса RegisterIoCDependencyRotateCommand зависимость разрешается.
10. Определить команду MacroCommand для выполнения последовательности команд.
MacroCommand в конструктор получает массив ICommand. Метод Execute последовательно выполняет все команды из массива.

Критерии приемки:

Для реализации MacroCommand не используются циклы.
Реализован тест "MacroCommand выполняет все команды из массива".
Реализован тест, который проверяет, что MacroCommand.Execute выбрасывает исключение, если одна из команд выбрасывает исключение, оставшиеся команды не выполняются.

11. Определить зависимость "Commands.Macro" в IoC, которая по массиву команд возвращает Макрокоманду.
Указание: Для регистрации зависимости определить команду RegisterIoCDependencyMacroCommand:

public class RegisterIoCDependencyMacroCommand : ICommand
{
    public void Execute()
  {
      // код, регистрирующий зависимость
    }
}
Критерии приемки:

Реализован тест, который проверяет, что при выполнении Execute класса RegisterDependencyMacroCommand зависимость разрешается.

12. Определить стратегию разрешения зависимости для макрокоманд.
Предположим, что при разрешении зависимости вида "Specs.<операция>" можно получить список наименований команд, которые образуют макрокоманду. Используя данный список и IoC необходимо получить Команды, сформировать из них список, по которому создать экземпляр MacroCommand.

class CreateMacroCommandStrategy(string commandSpec)
{
  ICommand Resolve(object[] args)
  {
    // код по конструированию зависимости
  }
}
Критерии приемки:

Циклы не используются.
Реализован тест, который проверяет, что при наличии зависимости "Macro.Test" и зависимостей соответствующих команд, макрокоманда разрешается успешно и все команды выполняются.
Реализованы тесты, которые проверяют, что в противном случае (п.2) метод Resolve выбрасывает исключение.

13. Регистрация зависимостей "Macro.Move" и "Macro.Rotate" в IoC.
Примечание: Считать, что зависимости "Specs.Move" и "Specs.Rotate" - заданы (это другая лабораторная работа). Для тестов задать зависимости с помощью Mock-объектов.

Указание: Для регистрации зависимости определить команду RegisterIoCDependencyMacroMoveRotate:

public class RegisterIoCDependencyMacroMoveRotate : ICommand
{
    public void Execute()
  {
      // код, регистрирующий зависимость
    }
}

14. Определить команду SendCommand для отправки команды.
SendCommand в конструктор получает команду ICommand и интерфейс ICommandReceiver. В методе Execute SendCommand вызывается метод Receive интерфейса ICommandReceiver, в который передается длительная команда.

Критерии приемки:

Реализован тест "SendCommand передает команду в IMessageReceiver", который проверяет, что при вызове метода Execute класса SendCommand вызывается метод Receive объекта ICommandReceiver с параметром - объектом длительной команды.
Реализован тест, который проверяет, что SendCommand.Execute выбрасывает исключение, если IMessageReceiver не может принять длительную команду.

15. Определить зависимость "Commands.Send" в IoC, которая по команде и объекту типа IMessageReceiver конструирует команду SendCommand.
Указание: Для регистрации зависимости определить команду RegisterIoCDependencySendCommand:

public class RegisterIoCDependencySendCommand : ICommand
{
    public void Execute()
  {
      // код, регистрирующий зависимость
    }
}
Критерии приемки:

Реализован тест, который проверяет, что при выполнении Execute класса RegisterDependencySendCommand зависимость разрешается.

16. Определить интерфейс ICommandInjectable
public interface ICommandInjectable
{
    void Inject(ICommand command);
}

17. Определить команду CommandInjectableCommand
Команда реализует два интерфейса ICommand и ICommandIjectable.

Критерии приемки:

Реализован тест, который проверяет, что после того как команда будет внедрена в объект класса CommandInjectableCommand, то она будет вызвана при выполнении метода Execute объекта класса CommandInjectableCommand.
Реализован тест, который проверяет, что вызов Execute класса CommandInjectableCommand выбрасывает исключение, если не была внедерена команда.

18. Определить зависисимость "Commands.CommandInjectable" в IoC, которая конструирует команду CommandInjectableCommand.
Указание: Для регистрации зависимости определить команду RegisterMacroCommand:

public class RegisterDependencyCommandInjectableCommand : ICommand
{
    public void Execute()
  {
      // код, регистрирующий зависимость
    }
}
Критерии приемки:

Реализован тест, который проверяет, что следующий код работает без выброса исключений:
Ioc.Resolve<ICommand>("Commands.CommadInjectable");
Ioc.Resolve<ICommandInjectable>("Commands.CommadInjectable");
Ioc.Resolve<CommandInjectableCommand>("Commands.CommadInjectable");

19. Определить зависимость "Actions.Start" для запуска длительной операции.
Необходимо так определить зависимость, чтобы следующий код позволял получать команду:

IDictionary<string, object> order = ...; // приказ о старте длительной операции
Ioc.Reolve<ICommand>("Actions.Start", order);
Сама регистрация зависимости должна быть выполнена в команде RegisterIoCDepenedncyActionsStart

public class RegisterIoCDependencyActionsStart : ICommand
{
    public void Execute()
  {
    // здесь кодж для регистрации зависимостей
  }
}
Примечание: Все дополнительные зависимости, которые будут использованы при реализации, кроме зависимостей, которые были оговорены выше, должны быть также зарегистрированы.

Критерии приемки:

Реализован тест, который проверяет, что при выполнении Execute класса RegisterIoCDependencyActionsStart зависимость разрешается.

20. Определить зависимость "Actions.Stop" для запуска длительной операции.
Необходимо так определить зависимость, чтобы следующий код позволял получать команду:

IDictionary<string, object> order = ...; // приказ об остановке длительной операции
Ioc.Reolve<ICommand>("Actions.Stop", order);
Сама регистрация зависимости должна быть выполнена в команде RegisterIoCDepenedncyActionsStop

public class RegisterIoCDependencyActionsStop : ICommand
{
    public void Execute()
  {
    // здесь кодж для регистрации зависимостей
  }
}
Критерии приемки:

Реализован тест, который проверяет, что при выполнении Execute класса RegisterIoCDependencyActionsStop зависимость разрешается.
Остановка команды выполняется за константное время.


Критерий приемки задания.
Задание принято, если все критерии к задачам выполнены.
Преподаватель на может придумать новое требование в игре, которое приведет к нарушению OCP.
Каждое задание оформляется отдельным Issues и веткой в github.
Необходимо создать issue на github. в него скопировать текст задачи полностью. Указать Assigner - тот, кто будет выполнять это issue. После этого создать ветку прямо на github для реализации issue. На клиенте теперь ветку не создаем, а выкачиваем из origin.